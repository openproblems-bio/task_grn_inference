#!/usr/bin/env bash

# sc_counts build-main
# 
# This wrapper script is auto-generated by viash 0.8.6 and is thus a derivative
# work thereof. This software comes with ABSOLUTELY NO WARRANTY from Data
# Intuitive.
# 
# The component may contain files which fall under a different license. The
# authors of this component should specify the license in the header of such
# files, or include a separate license file detailing the licenses of all included
# files.

set -e

if [ -z "$VIASH_TEMP" ]; then
  VIASH_TEMP=${VIASH_TEMP:-$VIASH_TMPDIR}
  VIASH_TEMP=${VIASH_TEMP:-$VIASH_TEMPDIR}
  VIASH_TEMP=${VIASH_TEMP:-$VIASH_TMP}
  VIASH_TEMP=${VIASH_TEMP:-$TMPDIR}
  VIASH_TEMP=${VIASH_TEMP:-$TMP}
  VIASH_TEMP=${VIASH_TEMP:-$TEMPDIR}
  VIASH_TEMP=${VIASH_TEMP:-$TEMP}
  VIASH_TEMP=${VIASH_TEMP:-/tmp}
fi

# define helper functions
# ViashQuote: put quotes around non flag values
# $1     : unquoted string
# return : possibly quoted string
# examples:
#   ViashQuote --foo      # returns --foo
#   ViashQuote bar        # returns 'bar'
#   Viashquote --foo=bar  # returns --foo='bar'
function ViashQuote {
  if [[ "$1" =~ ^-+[a-zA-Z0-9_\-]+=.+$ ]]; then
    echo "$1" | sed "s#=\(.*\)#='\1'#"
  elif [[ "$1" =~ ^-+[a-zA-Z0-9_\-]+$ ]]; then
    echo "$1"
  else
    echo "'$1'"
  fi
}
# ViashRemoveFlags: Remove leading flag
# $1     : string with a possible leading flag
# return : string without possible leading flag
# examples:
#   ViashRemoveFlags --foo=bar  # returns bar
function ViashRemoveFlags {
  echo "$1" | sed 's/^--*[a-zA-Z0-9_\-]*=//'
}
# ViashSourceDir: return the path of a bash file, following symlinks
# usage   : ViashSourceDir ${BASH_SOURCE[0]}
# $1      : Should always be set to ${BASH_SOURCE[0]}
# returns : The absolute path of the bash file
function ViashSourceDir {
  SOURCE="$1"
  while [ -h "$SOURCE" ]; do
    DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
    SOURCE="$(readlink "$SOURCE")"
    [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
  done
  cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd
}
# ViashFindTargetDir: return the path of the '.build.yaml' file, following symlinks
# usage   : ViashFindTargetDir 'ScriptPath'
# $1      : The location from where to start the upward search
# returns : The absolute path of the '.build.yaml' file
function ViashFindTargetDir {
  SOURCE="$1"
  while [[ "$SOURCE" != "" && ! -e "$SOURCE/.build.yaml" ]]; do
    SOURCE=${SOURCE%/*}
  done
  echo $SOURCE
}
# see https://en.wikipedia.org/wiki/Syslog#Severity_level
VIASH_LOGCODE_EMERGENCY=0
VIASH_LOGCODE_ALERT=1
VIASH_LOGCODE_CRITICAL=2
VIASH_LOGCODE_ERROR=3
VIASH_LOGCODE_WARNING=4
VIASH_LOGCODE_NOTICE=5
VIASH_LOGCODE_INFO=6
VIASH_LOGCODE_DEBUG=7
VIASH_VERBOSITY=$VIASH_LOGCODE_NOTICE

# ViashLog: Log events depending on the verbosity level
# usage: ViashLog 1 alert Oh no something went wrong!
# $1: required verbosity level
# $2: display tag
# $3+: messages to display
# stdout: Your input, prepended by '[$2] '.
function ViashLog {
  local required_level="$1"
  local display_tag="$2"
  shift 2
  if [ $VIASH_VERBOSITY -ge $required_level ]; then
    >&2 echo "[$display_tag]" "$@"
  fi
}

# ViashEmergency: log events when the system is unstable
# usage: ViashEmergency Oh no something went wrong.
# stdout: Your input, prepended by '[emergency] '.
function ViashEmergency {
  ViashLog $VIASH_LOGCODE_EMERGENCY emergency "$@"
}

# ViashAlert: log events when actions must be taken immediately (e.g. corrupted system database)
# usage: ViashAlert Oh no something went wrong.
# stdout: Your input, prepended by '[alert] '.
function ViashAlert {
  ViashLog $VIASH_LOGCODE_ALERT alert "$@"
}

# ViashCritical: log events when a critical condition occurs
# usage: ViashCritical Oh no something went wrong.
# stdout: Your input, prepended by '[critical] '.
function ViashCritical {
  ViashLog $VIASH_LOGCODE_CRITICAL critical "$@"
}

# ViashError: log events when an error condition occurs
# usage: ViashError Oh no something went wrong.
# stdout: Your input, prepended by '[error] '.
function ViashError {
  ViashLog $VIASH_LOGCODE_ERROR error "$@"
}

# ViashWarning: log potentially abnormal events
# usage: ViashWarning Something may have gone wrong.
# stdout: Your input, prepended by '[warning] '.
function ViashWarning {
  ViashLog $VIASH_LOGCODE_WARNING warning "$@"
}

# ViashNotice: log significant but normal events
# usage: ViashNotice This just happened.
# stdout: Your input, prepended by '[notice] '.
function ViashNotice {
  ViashLog $VIASH_LOGCODE_NOTICE notice "$@"
}

# ViashInfo: log normal events
# usage: ViashInfo This just happened.
# stdout: Your input, prepended by '[info] '.
function ViashInfo {
  ViashLog $VIASH_LOGCODE_INFO info "$@"
}

# ViashDebug: log all events, for debugging purposes
# usage: ViashDebug This just happened.
# stdout: Your input, prepended by '[debug] '.
function ViashDebug {
  ViashLog $VIASH_LOGCODE_DEBUG debug "$@"
}

# find source folder of this component
VIASH_META_RESOURCES_DIR=`ViashSourceDir ${BASH_SOURCE[0]}`

# find the root of the built components & dependencies
VIASH_TARGET_DIR=`ViashFindTargetDir $VIASH_META_RESOURCES_DIR`

# define meta fields
VIASH_META_FUNCTIONALITY_NAME="sc_counts"
VIASH_META_EXECUTABLE="$VIASH_META_RESOURCES_DIR/$VIASH_META_FUNCTIONALITY_NAME"
VIASH_META_CONFIG="$VIASH_META_RESOURCES_DIR/.config.vsh.yaml"
VIASH_META_TEMP_DIR="$VIASH_TEMP"


# ViashHelp: Display helpful explanation about this executable
function ViashHelp {
  echo "sc_counts build-main"
  echo ""
  echo "Arguments:"
  echo "    --perturbation_counts"
  echo "        type: file, required parameter, file must exist"
  echo "        example: resources_test/datasets_raw/op_perturbation_counts.h5ad"
  echo ""
  echo "    --pseudobulked_data"
  echo "        type: file, output, file must exist"
  echo "        example: resources_test/evaluation_datasets/op_perturbation.h5ad"
  echo ""
  echo "    --pseudobulked_data_f"
  echo "        type: file, output, file must exist"
  echo "        example: resources_test/grn-benchmark/perturbation_data.h5ad"
}

# initialise array
VIASH_POSITIONAL_ARGS=''
VIASH_MODE='run'

while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            ViashHelp
            exit
            ;;
        ---v|---verbose)
            let "VIASH_VERBOSITY=VIASH_VERBOSITY+1"
            shift 1
            ;;
        ---verbosity)
            VIASH_VERBOSITY="$2"
            shift 2
            ;;
        ---verbosity=*)
            VIASH_VERBOSITY="$(ViashRemoveFlags "$1")"
            shift 1
            ;;
        --version)
            echo "sc_counts build-main"
            exit
            ;;
        --perturbation_counts)
            [ -n "$VIASH_PAR_PERTURBATION_COUNTS" ] && ViashError Bad arguments for option \'--perturbation_counts\': \'$VIASH_PAR_PERTURBATION_COUNTS\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_PERTURBATION_COUNTS="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --perturbation_counts. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --perturbation_counts=*)
            [ -n "$VIASH_PAR_PERTURBATION_COUNTS" ] && ViashError Bad arguments for option \'--perturbation_counts=*\': \'$VIASH_PAR_PERTURBATION_COUNTS\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_PERTURBATION_COUNTS=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --pseudobulked_data)
            [ -n "$VIASH_PAR_PSEUDOBULKED_DATA" ] && ViashError Bad arguments for option \'--pseudobulked_data\': \'$VIASH_PAR_PSEUDOBULKED_DATA\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_PSEUDOBULKED_DATA="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --pseudobulked_data. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --pseudobulked_data=*)
            [ -n "$VIASH_PAR_PSEUDOBULKED_DATA" ] && ViashError Bad arguments for option \'--pseudobulked_data=*\': \'$VIASH_PAR_PSEUDOBULKED_DATA\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_PSEUDOBULKED_DATA=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --pseudobulked_data_f)
            [ -n "$VIASH_PAR_PSEUDOBULKED_DATA_F" ] && ViashError Bad arguments for option \'--pseudobulked_data_f\': \'$VIASH_PAR_PSEUDOBULKED_DATA_F\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_PSEUDOBULKED_DATA_F="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --pseudobulked_data_f. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --pseudobulked_data_f=*)
            [ -n "$VIASH_PAR_PSEUDOBULKED_DATA_F" ] && ViashError Bad arguments for option \'--pseudobulked_data_f=*\': \'$VIASH_PAR_PSEUDOBULKED_DATA_F\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_PSEUDOBULKED_DATA_F=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        ---cpus)
            [ -n "$VIASH_META_CPUS" ] && ViashError Bad arguments for option \'---cpus\': \'$VIASH_META_CPUS\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_META_CPUS="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to ---cpus. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        ---cpus=*)
            [ -n "$VIASH_META_CPUS" ] && ViashError Bad arguments for option \'---cpus=*\': \'$VIASH_META_CPUS\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_META_CPUS=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        ---memory)
            [ -n "$VIASH_META_MEMORY" ] && ViashError Bad arguments for option \'---memory\': \'$VIASH_META_MEMORY\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_META_MEMORY="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to ---memory. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        ---memory=*)
            [ -n "$VIASH_META_MEMORY" ] && ViashError Bad arguments for option \'---memory=*\': \'$VIASH_META_MEMORY\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_META_MEMORY=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        *)  # positional arg or unknown option
            # since the positional args will be eval'd, can we always quote, instead of using ViashQuote
            VIASH_POSITIONAL_ARGS="$VIASH_POSITIONAL_ARGS '$1'"
            [[ $1 == -* ]] && ViashWarning $1 looks like a parameter but is not a defined parameter and will instead be treated as a positional argument. Use "--help" to get more information on the parameters.
            shift # past argument
            ;;
    esac
done

# parse positional parameters
eval set -- $VIASH_POSITIONAL_ARGS


# setting computational defaults

# helper function for parsing memory strings
function ViashMemoryAsBytes {
  local memory=`echo "$1" | tr '[:upper:]' '[:lower:]' | tr -d '[:space:]'`
  local memory_regex='^([0-9]+)([kmgtp]b?|b)$'
  if [[ $memory =~ $memory_regex ]]; then
    local number=${memory/[^0-9]*/}
    local symbol=${memory/*[0-9]/}
    
    case $symbol in
      b)      memory_b=$number ;;
      kb|k)   memory_b=$(( $number * 1024 )) ;;
      mb|m)   memory_b=$(( $number * 1024 * 1024 )) ;;
      gb|g)   memory_b=$(( $number * 1024 * 1024 * 1024 )) ;;
      tb|t)   memory_b=$(( $number * 1024 * 1024 * 1024 * 1024 )) ;;
      pb|p)   memory_b=$(( $number * 1024 * 1024 * 1024 * 1024 * 1024 )) ;;
    esac
    echo "$memory_b"
  fi
}
# compute memory in different units
if [ ! -z ${VIASH_META_MEMORY+x} ]; then
  VIASH_META_MEMORY_B=`ViashMemoryAsBytes $VIASH_META_MEMORY`
  # do not define other variables if memory_b is an empty string
  if [ ! -z "$VIASH_META_MEMORY_B" ]; then
    VIASH_META_MEMORY_KB=$(( ($VIASH_META_MEMORY_B+1023) / 1024 ))
    VIASH_META_MEMORY_MB=$(( ($VIASH_META_MEMORY_KB+1023) / 1024 ))
    VIASH_META_MEMORY_GB=$(( ($VIASH_META_MEMORY_MB+1023) / 1024 ))
    VIASH_META_MEMORY_TB=$(( ($VIASH_META_MEMORY_GB+1023) / 1024 ))
    VIASH_META_MEMORY_PB=$(( ($VIASH_META_MEMORY_TB+1023) / 1024 ))
  else
    # unset memory if string is empty
    unset $VIASH_META_MEMORY_B
  fi
fi
# unset nproc if string is empty
if [ -z "$VIASH_META_CPUS" ]; then
  unset $VIASH_META_CPUS
fi


# check whether required parameters exist
if [ -z ${VIASH_PAR_PERTURBATION_COUNTS+x} ]; then
  ViashError '--perturbation_counts' is a required argument. Use "--help" to get more information on the parameters.
  exit 1
fi
if [ -z ${VIASH_META_FUNCTIONALITY_NAME+x} ]; then
  ViashError 'functionality_name' is a required argument. Use "--help" to get more information on the parameters.
  exit 1
fi
if [ -z ${VIASH_META_RESOURCES_DIR+x} ]; then
  ViashError 'resources_dir' is a required argument. Use "--help" to get more information on the parameters.
  exit 1
fi
if [ -z ${VIASH_META_EXECUTABLE+x} ]; then
  ViashError 'executable' is a required argument. Use "--help" to get more information on the parameters.
  exit 1
fi
if [ -z ${VIASH_META_CONFIG+x} ]; then
  ViashError 'config' is a required argument. Use "--help" to get more information on the parameters.
  exit 1
fi
if [ -z ${VIASH_META_TEMP_DIR+x} ]; then
  ViashError 'temp_dir' is a required argument. Use "--help" to get more information on the parameters.
  exit 1
fi

# check whether required files exist
if [ ! -z "$VIASH_PAR_PERTURBATION_COUNTS" ] && [ ! -e "$VIASH_PAR_PERTURBATION_COUNTS" ]; then
  ViashError "Input file '$VIASH_PAR_PERTURBATION_COUNTS' does not exist."
  exit 1
fi

# check whether parameters values are of the right type
if [[ -n "$VIASH_META_CPUS" ]]; then
  if ! [[ "$VIASH_META_CPUS" =~ ^[-+]?[0-9]+$ ]]; then
    ViashError 'cpus' has to be an integer. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi
if [[ -n "$VIASH_META_MEMORY_B" ]]; then
  if ! [[ "$VIASH_META_MEMORY_B" =~ ^[-+]?[0-9]+$ ]]; then
    ViashError 'memory_b' has to be a long. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi
if [[ -n "$VIASH_META_MEMORY_KB" ]]; then
  if ! [[ "$VIASH_META_MEMORY_KB" =~ ^[-+]?[0-9]+$ ]]; then
    ViashError 'memory_kb' has to be a long. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi
if [[ -n "$VIASH_META_MEMORY_MB" ]]; then
  if ! [[ "$VIASH_META_MEMORY_MB" =~ ^[-+]?[0-9]+$ ]]; then
    ViashError 'memory_mb' has to be a long. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi
if [[ -n "$VIASH_META_MEMORY_GB" ]]; then
  if ! [[ "$VIASH_META_MEMORY_GB" =~ ^[-+]?[0-9]+$ ]]; then
    ViashError 'memory_gb' has to be a long. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi
if [[ -n "$VIASH_META_MEMORY_TB" ]]; then
  if ! [[ "$VIASH_META_MEMORY_TB" =~ ^[-+]?[0-9]+$ ]]; then
    ViashError 'memory_tb' has to be a long. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi
if [[ -n "$VIASH_META_MEMORY_PB" ]]; then
  if ! [[ "$VIASH_META_MEMORY_PB" =~ ^[-+]?[0-9]+$ ]]; then
    ViashError 'memory_pb' has to be a long. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi

# create parent directories of output files, if so desired
if [ ! -z "$VIASH_PAR_PSEUDOBULKED_DATA" ] && [ ! -d "$(dirname "$VIASH_PAR_PSEUDOBULKED_DATA")" ]; then
  mkdir -p "$(dirname "$VIASH_PAR_PSEUDOBULKED_DATA")"
fi
if [ ! -z "$VIASH_PAR_PSEUDOBULKED_DATA_F" ] && [ ! -d "$(dirname "$VIASH_PAR_PSEUDOBULKED_DATA_F")" ]; then
  mkdir -p "$(dirname "$VIASH_PAR_PSEUDOBULKED_DATA_F")"
fi


# set dependency paths


ViashDebug "Running command: bash"
cat << VIASHEOF | bash
set -e
tempscript=\$(mktemp "$VIASH_META_TEMP_DIR/viash-run-sc_counts-XXXXXX").py
function clean_up {
  rm "\$tempscript"
}
function interrupt {
  echo -e "\nCTRL-C Pressed..."
  exit 1
}
trap clean_up EXIT
trap interrupt INT SIGINT
cat > "\$tempscript" << 'VIASHMAIN'
# !pip install sctk anndata
# !aws s3 cp s3://openproblems-bio/public/neurips-2023-competition/sc_counts.h5ad  ./resources_raw/ --no-sign-request

import anndata as ad 
import pandas as pd
import numpy as np
import sctk
from scipy import sparse
import scanpy as sc

## VIASH START
# The following code has been auto-generated by Viash.
par = {
  'perturbation_counts': $( if [ ! -z ${VIASH_PAR_PERTURBATION_COUNTS+x} ]; then echo "r'${VIASH_PAR_PERTURBATION_COUNTS//\'/\'\"\'\"r\'}'"; else echo None; fi ),
  'pseudobulked_data': $( if [ ! -z ${VIASH_PAR_PSEUDOBULKED_DATA+x} ]; then echo "r'${VIASH_PAR_PSEUDOBULKED_DATA//\'/\'\"\'\"r\'}'"; else echo None; fi ),
  'pseudobulked_data_f': $( if [ ! -z ${VIASH_PAR_PSEUDOBULKED_DATA_F+x} ]; then echo "r'${VIASH_PAR_PSEUDOBULKED_DATA_F//\'/\'\"\'\"r\'}'"; else echo None; fi )
}
meta = {
  'functionality_name': $( if [ ! -z ${VIASH_META_FUNCTIONALITY_NAME+x} ]; then echo "r'${VIASH_META_FUNCTIONALITY_NAME//\'/\'\"\'\"r\'}'"; else echo None; fi ),
  'resources_dir': $( if [ ! -z ${VIASH_META_RESOURCES_DIR+x} ]; then echo "r'${VIASH_META_RESOURCES_DIR//\'/\'\"\'\"r\'}'"; else echo None; fi ),
  'executable': $( if [ ! -z ${VIASH_META_EXECUTABLE+x} ]; then echo "r'${VIASH_META_EXECUTABLE//\'/\'\"\'\"r\'}'"; else echo None; fi ),
  'config': $( if [ ! -z ${VIASH_META_CONFIG+x} ]; then echo "r'${VIASH_META_CONFIG//\'/\'\"\'\"r\'}'"; else echo None; fi ),
  'temp_dir': $( if [ ! -z ${VIASH_META_TEMP_DIR+x} ]; then echo "r'${VIASH_META_TEMP_DIR//\'/\'\"\'\"r\'}'"; else echo None; fi ),
  'cpus': $( if [ ! -z ${VIASH_META_CPUS+x} ]; then echo "int(r'${VIASH_META_CPUS//\'/\'\"\'\"r\'}')"; else echo None; fi ),
  'memory_b': $( if [ ! -z ${VIASH_META_MEMORY_B+x} ]; then echo "int(r'${VIASH_META_MEMORY_B//\'/\'\"\'\"r\'}')"; else echo None; fi ),
  'memory_kb': $( if [ ! -z ${VIASH_META_MEMORY_KB+x} ]; then echo "int(r'${VIASH_META_MEMORY_KB//\'/\'\"\'\"r\'}')"; else echo None; fi ),
  'memory_mb': $( if [ ! -z ${VIASH_META_MEMORY_MB+x} ]; then echo "int(r'${VIASH_META_MEMORY_MB//\'/\'\"\'\"r\'}')"; else echo None; fi ),
  'memory_gb': $( if [ ! -z ${VIASH_META_MEMORY_GB+x} ]; then echo "int(r'${VIASH_META_MEMORY_GB//\'/\'\"\'\"r\'}')"; else echo None; fi ),
  'memory_tb': $( if [ ! -z ${VIASH_META_MEMORY_TB+x} ]; then echo "int(r'${VIASH_META_MEMORY_TB//\'/\'\"\'\"r\'}')"; else echo None; fi ),
  'memory_pb': $( if [ ! -z ${VIASH_META_MEMORY_PB+x} ]; then echo "int(r'${VIASH_META_MEMORY_PB//\'/\'\"\'\"r\'}')"; else echo None; fi )
}
dep = {
  
}

## VIASH END

def preprocess_sc(par):
    # clean up
    sc_counts = ad.read_h5ad(par['perturbation_counts'])
    sc_counts.obs = sc_counts.obs[['well', 'row', 'col', 'plate_name', 'cell_type', 'donor_id', 'sm_name']]
    sc_counts.X = sc_counts.layers['counts']
    del sc_counts.layers 
    del sc_counts.obsm 
    sc_counts.var_names_make_unique()
    # merge cell types
    CELL_TYPES = ['NK cells', 'T cells CD4+', 'T cells CD8+', 'T regulatory cells', 'B cells', 'Myeloid cells']
    T_cell_types = ['T regulatory cells', 'T cells CD8+', 'T cells CD4+']
    cell_type_map = {cell_type: 'T cells' if cell_type in T_cell_types else cell_type for cell_type in CELL_TYPES}
    sc_counts.obs['cell_type'] = sc_counts.obs['cell_type'].map(cell_type_map)
    sc_counts.obs['cell_type'].unique()

    # qc 
    sctk.calculate_qc(sc_counts)
    sctk.cellwise_qc(sc_counts)

    # filtering
    # cell wise
    filter_percent_hb = sc_counts.obs.percent_hb>.2
    filter_percent_hb.sum()
    # gene wise
    plates = sc_counts.obs['plate_name'].unique()

    # Step 2: Initialize a DataFrame to store counts
    gene_counts_per_plate = pd.DataFrame(index=sc_counts.var_names, columns=plates, dtype=int)

    # Step 3: Iterate over each plate and calculate expression counts
    for plate in plates:
        # Subset the AnnData object for the current plate
        subset = sc_counts[sc_counts.obs['plate_name'] == plate]

        # Calculate expression counts (genes x cells > 0)
        expressed_genes = (subset.X > 0).sum(axis=0)

        # Check if the result needs conversion from sparse matrix format
        if isinstance(expressed_genes, np.matrix):
            expressed_genes = np.array(expressed_genes).flatten()

        # Store the counts in the DataFrame
        gene_counts_per_plate[plate] = expressed_genes

    # Step 4: Aggregate counts across plates (max or sum based on the requirement)
    # We use \`max\` here to find if any gene meets the criteria in at least one plate
    max_counts = gene_counts_per_plate.max(axis=1)

    # Step 5: Create a mask for genes to keep (genes expressed in at least 100 cells in any plate)
    genes_to_keep = max_counts >= 100
    print('retained genes:', genes_to_keep.sum())
    # actual filtering
    sc_counts = sc_counts[(~filter_percent_hb), genes_to_keep]
    # clean
    sc_counts.obs = sc_counts.obs[['cell_type', 'sm_name', 'donor_id', 'row', 'plate_name', 'well']]
    sc_counts.var = sc_counts.var[[]]

    del sc_counts.obsm
    del sc_counts.uns
    return sc_counts
def sum_by(adata: ad.AnnData, col: str) -> ad.AnnData:
    """
    Adapted from this forum post: 
    https://discourse.scverse.org/t/group-sum-rows-based-on-jobs-feature/371/4
    """
    
    assert pd.api.types.is_categorical_dtype(adata.obs[col])

    # sum \`.X\` entries for each unique value in \`col\`
    cat = adata.obs[col].values

    indicator = sparse.coo_matrix(
        (
            np.broadcast_to(True, adata.n_obs),
            (cat.codes, np.arange(adata.n_obs))
        ),
        shape=(len(cat.categories), adata.n_obs),
    )
  
    sum_adata = ad.AnnData(
        indicator @ adata.X,
        var=adata.var,
        obs=pd.DataFrame(index=cat.categories),
    )
    
    # copy over \`.obs\` values that have a one-to-one-mapping with \`.obs[col]\`
    obs_cols = adata.obs.columns
    obs_cols = list(set(adata.obs.columns) - set([col]))
    
    one_to_one_mapped_obs_cols = []
    nunique_in_col = adata.obs[col].nunique()
    for other_col in obs_cols:
        if len(adata.obs[[col, other_col]].drop_duplicates()) == nunique_in_col:
            one_to_one_mapped_obs_cols.append(other_col)

    joining_df = adata.obs[[col] + one_to_one_mapped_obs_cols].drop_duplicates().set_index(col)
    assert (sum_adata.obs.index == sum_adata.obs.join(joining_df).index).all()
    sum_adata.obs = sum_adata.obs.join(joining_df)
    sum_adata.obs.index.name = col
    sum_adata.obs = sum_adata.obs.reset_index()
    sum_adata.obs.index = sum_adata.obs.index.astype('str')

    return sum_adata
def pseudobulk_sum_func(sc_counts):
    # pseudobulk
    #group cell types per well
    sc_counts.obs['plate_well_cell_type'] = sc_counts.obs['plate_name'].astype('str') \\
        + '_' + sc_counts.obs['well'].astype('str') \\
        + '_' + sc_counts.obs['cell_type'].astype('str')
    sc_counts.obs['plate_well_cell_type'] = sc_counts.obs['plate_well_cell_type'].astype('category')
    bulk_adata = sum_by(sc_counts, 'plate_well_cell_type')
    bulk_adata.obs['cell_count'] = sc_counts.obs.groupby('plate_well_cell_type').size().values
    bulk_adata.X = np.array(bulk_adata.X.todense())

    print('ratio of missingness' , (bulk_adata.X==0).sum()/bulk_adata.X.size)
    bulk_adata.var = bulk_adata.var.reset_index()
    bulk_adata.var.set_index('index', inplace=True)

    bulk_adata.X = np.nan_to_num(bulk_adata.X, nan=0)
    return bulk_adata
def pseudobulk_mean_func(bulk_adata):
    bulk_adata.layers['counts'] = bulk_adata.X.copy()
    rows_adj = []
    for i, row in enumerate(bulk_adata.X):
        count = bulk_adata.obs.cell_count[i]
        rows_adj.append(row/count)

    bulk_adata.layers['n_counts'] = np.asarray(rows_adj)

    return bulk_adata
def filter_func(bulk_adata):
    '''Filters pseudobulked data by removing outliers compound, 
    samples with low cell counts, and genes with low coverage
    '''
    ### filter
    # samples with less than 10 cells
    bulk_adata_filtered = bulk_adata.copy()
    bulk_adata_filtered.obs['donor_id'] = bulk_adata_filtered.obs.donor_id.map({'Donor 1': 'donor_0', 'Donor 2': 'donor_1', 'Donor 3': 'donor_2'})
    # toxic ones
    outliers_toxic = ['Alvocidib', 'UNII-BXU45ZH6LI', 'CGP 60474', 'BMS-387032']
    bulk_adata_filtered = bulk_adata_filtered[~bulk_adata_filtered.obs.sm_name.isin(outliers_toxic),:]
    # remove those with less than 10 cells left 

    mask_low_cell_count = bulk_adata_filtered.obs.cell_count < cell_counts_t
    bulk_adata_filtered = bulk_adata_filtered[~mask_low_cell_count]
    
    # remove those that have less than 2 cells types left per donor
    to_go_compounds = []
    for donor_id in bulk_adata_filtered.obs.donor_id.unique():
        adata_donor = bulk_adata_filtered[bulk_adata_filtered.obs.donor_id.eq(donor_id)]
        cell_type_n = adata_donor.obs.groupby('sm_name').size()
        to_go_compounds.append(cell_type_n[cell_type_n<=2].index.astype(str))
    to_go_compounds = np.unique(np.concatenate(to_go_compounds))
    outliers_two_celltype = ['CEP-18770 (Delanzomib)', 'IN1451', 'MLN 2238', 'Oprozomib (ONX 0912)']
    # assert np.all(to_go_compounds==outliers_two_celltype)
    bulk_adata_filtered = bulk_adata_filtered[~bulk_adata_filtered.obs.sm_name.isin(to_go_compounds),:]

    # remove big class misbalance in all donors 
    outliers_misbalance_all = ['Proscillaridin A;Proscillaridin-A'] 
    bulk_adata_filtered = bulk_adata_filtered[~bulk_adata_filtered.obs.sm_name.isin(outliers_misbalance_all),:]
    # remove big class misbalance in 1 donor
    outliers_misbalance_donor_2 = ['Vorinostat']
    bulk_adata_filtered = bulk_adata_filtered[~ (bulk_adata_filtered.obs.sm_name.isin(outliers_misbalance_donor_2) & (bulk_adata_filtered.obs.donor_id=='donor_1')),:]
    outliers_misbalance_donor_3 = ['AT13387', 'Ganetespib (STA-9090)']
    bulk_adata_filtered = bulk_adata_filtered[~ (bulk_adata_filtered.obs.sm_name.isin(outliers_misbalance_donor_3) & (bulk_adata_filtered.obs.donor_id=='donor_2')),:]
    print(f"number of initial samples: {len(bulk_adata)}, number of samples after filtering: {len(bulk_adata_filtered)}")
    # low gene coverage
    mask_to_go_genes = ((bulk_adata_filtered.X == 0).sum(axis=0)/bulk_adata_filtered.shape[0])>0.7
    print('number of removed genes:', mask_to_go_genes.sum())
    bulk_adata_filtered = bulk_adata_filtered[:,~mask_to_go_genes] 
    bulk_adata_filtered.obs.drop(columns=['plate_well_cell_type'], inplace=True)
    # for the sake of seurat
    for key in ['cell_type','plate_name']:
        bulk_adata_filtered.obs[key] = bulk_adata_filtered.obs[key].astype(str)
    return bulk_adata_filtered

test_flag = False
if 'test' in par['perturbation_counts'].split('/')[0]:
    print('Test')
    test_flag = True
    cell_counts_t = 1
    cell_type_t = 1
else:
    cell_counts_t = 10
    cell_type_t = 2
    
sc_counts_f = preprocess_sc(par)
bulk_adata = pseudobulk_sum_func(sc_counts_f)
bulk_adata = pseudobulk_mean_func(bulk_adata)
bulk_adata.write(par['pseudobulked_data'])
bulk_adata_filtered = filter_func(bulk_adata)
bulk_adata_filtered.write(par['pseudobulked_data_f'])
VIASHMAIN
python -B "\$tempscript" &
wait "\$!"

VIASHEOF


# check whether required files exist
if [ ! -z "$VIASH_PAR_PSEUDOBULKED_DATA" ] && [ ! -e "$VIASH_PAR_PSEUDOBULKED_DATA" ]; then
  ViashError "Output file '$VIASH_PAR_PSEUDOBULKED_DATA' does not exist."
  exit 1
fi
if [ ! -z "$VIASH_PAR_PSEUDOBULKED_DATA_F" ] && [ ! -e "$VIASH_PAR_PSEUDOBULKED_DATA_F" ]; then
  ViashError "Output file '$VIASH_PAR_PSEUDOBULKED_DATA_F' does not exist."
  exit 1
fi


exit 0
